// Copyright 2025 NXP
//
// SPDX-License-Identifier: BSD-3-Clause
//! McuBoot Command Response Tag Definitions
//!
//! This module defines the response tags and parsing logic for McuBoot command responses.
//! Each McuBoot command returns a response with a specific tag that indicates the type
//! of response data being returned. This module provides strongly-typed parsing of these
//! responses into appropriate Rust data structures.

use super::ToAddress;

/// McuBoot command response tag enumeration
///
/// Represents the different types of responses that can be returned by McuBoot commands.
/// Each variant corresponds to a specific response type and contains the appropriate
/// data structure for that response.
#[repr(u8)]
#[derive(Clone, Debug, strum::EnumDiscriminants)]
#[strum_discriminants(derive(derive_more::TryFrom), try_from(repr))]
#[strum_discriminants(vis(pub(self)))]
pub enum CmdResponseTag {
    /// Generic response containing a single status or result value
    #[strum(to_string = "Generic Response")]
    Generic(u32) = 0xA0,

    /// Memory read response containing the actual data read from memory
    #[strum(to_string = "Read Memory Response: {0:?}")]
    ReadMemory(Box<[u8]>) = 0xA3,

    /// Property query response containing property values
    #[strum(to_string = "Get Property Response: {0:#04x?}")]
    GetProperty(Box<[u32]>) = 0xA7,

    /// Flash read once response containing the read value
    #[strum(to_string = "Flash Read Once Response")]
    FlashReadOnce(u32) = 0xAF,

    /// Flash read resource response
    #[strum(to_string = "Flash Read Resource Response")]
    FlashReadResource = 0xB0,

    /// Key blob creation response
    #[strum(to_string = "Create Key Blob")]
    KeyBlob = 0xB3,

    /// Key provisioning response containing operation results
    #[strum(to_string = "Key Provisioning Response: {0:02X?}")]
    KeyProvisioning(Box<[u32]>, Option<Box<[u8]>>) = 0xB5,

    /// Trust provisioning response containing operation results
    #[strum(to_string = "Trust Provisioning Response: {0:02X?}")]
    TrustProvisioning(Box<[u32]>) = 0xB6,
}

impl ToAddress for CmdResponseTag {}

/// Type alias for the discriminants enum generated by strum
type CmdResTagDis = CmdResponseTagDiscriminants;

impl CmdResponseTag {
    /// Parse a response from raw data based on response code
    ///
    /// This method takes the response code, parameter data, and optional data phase
    /// content and constructs the appropriate response variant. The parsing logic
    /// handles the different data formats expected by each response type.
    ///
    /// # Arguments
    /// * `code` - Response code identifying the response type
    /// * `params` - Parameter data from the response packet
    /// * `data_phase` - Optional data phase content (for responses that include binary data)
    ///
    /// # Returns
    /// If `Some`, the appropriate [`CmdResponseTag`] variant containing the parsed response data. If
    /// None, it means there was no appropriate command number for `code`.
    ///
    /// # Panics
    /// Panics if required data is missing or `code` is not yet implemented.
    #[must_use]
    pub fn from_code(code: u8, params: &[u8], data_phase: Option<&[u8]>) -> Option<CmdResponseTag> {
        CmdResTagDis::try_from(code)
            .map(|tag| match tag {
                CmdResTagDis::Generic => CmdResponseTag::Generic(to_u32(params).next().unwrap()),
                CmdResTagDis::GetProperty => CmdResponseTag::GetProperty(to_u32(params).collect()),
                CmdResTagDis::ReadMemory => {
                    CmdResponseTag::ReadMemory(data_phase.expect("no data phase sent for ReadMemory!").into())
                }
                CmdResTagDis::FlashReadOnce => {
                    // The Flash Read Once response contains the value in the params
                    // The first parameter is typically the byte count, and the second is the actual data
                    let values: Vec<u32> = to_u32(params).collect();
                    if values.len() >= 2 {
                        CmdResponseTag::FlashReadOnce(values[1])
                    } else {
                        // If there's only one value or none, return 0 or handle as appropriate
                        CmdResponseTag::FlashReadOnce(values.first().copied().unwrap_or(0))
                    }
                }
                CmdResTagDis::TrustProvisioning => CmdResponseTag::TrustProvisioning(to_u32(params).collect()),
                CmdResTagDis::KeyProvisioning => {
                    let data_phase_boxed = data_phase.map(Box::from);
                    CmdResponseTag::KeyProvisioning(to_u32(params).collect(), data_phase_boxed)
                }
                _ => unimplemented!("this CommandResponse parser was not yet implemented"),
            })
            .ok()
    }
}

fn to_u32(params: &[u8]) -> impl Iterator<Item = u32> + '_ {
    params
        .chunks_exact(4)
        .map(|bytes| u32::from_le_bytes(bytes.try_into().unwrap()))
}
